"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_vanilla-marquee_dist_vanilla-marquee_js"],{

/***/ "./node_modules/vanilla-marquee/dist/vanilla-marquee.js":
/*!**************************************************************!*\
  !*** ./node_modules/vanilla-marquee/dist/vanilla-marquee.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ marquee)\n/* harmony export */ });\n// @ts-check\n/**\n * Shorthand for `document.getElementsByClassName`\n *\n * @param {String} selClass - The selector's class\n * @param {Element|HTMLElement|Document} [parent=document] - Parent element\n *\n * @returns {HTMLCollectionOf<Element>} - The selected elements\n */\n\nfunction byClass(selClass, parent = document) {\n  return parent.getElementsByClassName(selClass);\n}\n/**\n * Shorthand for `document.querySelector`\n *\n * @param {String} selector - Selector\n * @param {Element|HTMLElement|Document} [parent=document] - Parent element\n *\n * @returns {Element|HTMLElementTagNameMap|SVGElementTagNameMap|null} - The selected element\n */\n\nfunction query(selector, parent = document) {\n  return parent.querySelector(selector);\n}\n/**\n * Shorthand for `document.querySelectorAll`\n *\n * @param {String} selector - Selector\n * @param {Element|HTMLElement|Document} [parent=document] - Parent element\n *\n * @returns {NodeList} - The selected element\n */\n\nfunction queryAll(selector, parent = document) {\n  return parent.querySelectorAll(selector);\n}\n\n// @ts-check\n\n/**\n * Foreach polyfill for NodeList and HTMLCollection\n * https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/\n *\n * @param {Array<any>|NodeList|HTMLCollection} els - A list of elements\n * @param {foreachCB} fn - Callback containing ( value, index ) as arguments\n * @param {Function} [scope] - Scope\n */\nfunction forEachHTML(els, fn, scope) {\n  for (let i = 0, numEls = els.length; i < numEls; i++) fn.call(scope, els[i], i);\n}\n\n// @ts-check\n/**\n * Shorthand for `element.classList.add`, works with multiple nodes\n *\n * @param {Element|HTMLElement|HTMLCollection|NodeList} el - A list of elements\n * @param {...String} classes - Classes to add\n */\n\nfunction addClass(el, ...classes) {\n  // @ts-ignore\n  if (el.length === undefined) {\n    // @ts-ignore\n    addClassEl(el, ...classes);\n  } else {\n    // @ts-ignore\n    forEachHTML(el, currEl => {\n      addClassEl(currEl, ...classes);\n    });\n  }\n  /**\n   * Adds classes to a single element\n   *\n   * @param {Element|HTMLElement} elem - An HTML element\n   * @param {...String} remClass - Classes to add\n   */\n\n\n  function addClassEl(elem, ...remClass) {\n    remClass.forEach(singleClass => {\n      elem.classList.add(singleClass);\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Shorthand for `element.addEventListener`\n *\n * @param {Element|HTMLElement|Window|Document|MediaQueryList} el - A list of elements\n * @param {String} ev - Event's name\n * @param {EventListenerOrEventListenerObject} fn - Event's function\n * @param {Object} [opts] - Optional event options\n */\nfunction addEvent(el, ev, fn, opts) {\n  el.addEventListener(ev, fn, opts);\n}\n/**\n * Shorthand for `element.removeEventListener`\n *\n * @param {Element|HTMLElement|Window|Document|MediaQueryList} el - A list of elements\n * @param {String} ev - Event's name\n * @param {EventListenerOrEventListenerObject} fn - Event's function\n * @param {Object} [opts] - Optional event options\n */\n\nfunction removeEvent(el, ev, fn, opts) {\n  el.removeEventListener(ev, fn, opts);\n}\n\n// @ts-check\n\n/**\n * Shorthand for `element.getAttribute`\n *\n * @param {Element|HTMLElement} el - An HTML element\n * @param {String} attr - The attribute to retrieve\n *\n * @returns {String|null} - The attribute's value\n */\nfunction getAttr(el, attr) {\n  return el.getAttribute(attr);\n}\n/**\n * Shorthand for `element.setAttribute`\n *\n * @param {Element|HTMLElement} el - An HTML element\n * @param {String} attr - The attribute to retrieve\n * @param {String} val - The value to set to the attribute\n */\n\nfunction setAttr(el, attr, val) {\n  el.setAttribute(attr, val);\n}\n/**\n * Shorthand for `element.removeAttribute`\n *\n * @param {Element|HTMLElement} el - An HTML element\n * @param {String} attr - The attribute to remove\n */\n\nfunction remAttr(el, attr) {\n  el.removeAttribute(attr);\n}\n\n/**\n * @typedef defaultOptions\n * @property {String} [css3easing='linear'] - A css3 transtion timing\n * @property {Number} [delayBeforeStart=1000] - Time in milliseconds before the marquee starts animating\n * @property {String} [direction='left'] - Direction towards which the marquee will animate ` 'left' | 'right' | 'up' | 'down'`\n * @property {Boolean} [duplicated=false] - Should the marquee be duplicated to show an effect of continuous flow. Use this only when the text is shorter than the container\n * @property {Number} [duration=5000] - Duration in milliseconds in which you want your element to travel\n * @property {Number} [gap=20] - Gap in pixels between the tickers. Will work only when the `duplicated` option is set to `true`\n * @property {Boolean} [pauseOnHover=false] - Pause the marquee on hover\n * @property {Boolean} [recalcResize=false] - Recalculate the marquee position on resize (breaks compatibility with jquery.marquee)\n * @property {Number} [speed=0] - Speed will override duration. Speed allows you to set a relatively constant marquee speed regardless of the width of the containing element. Speed is measured in pixels/second\n * @property {Boolean} [startVisible=false] - The marquee will be visible from the start if set to `true`\n */\nconst defOpts = {\n  css3easing:       'linear',\n  delayBeforeStart: 1000,\n  direction:        'left',\n  duplicated:       false,\n  duration:         5000,\n  gap:              20,\n  pauseOnHover:     false,\n  recalcResize:     false,\n  speed:            0,\n  startVisible:     false,\n};\n\nlet instances = 0;\n\n/**\n * Vanilla js marquee based on jQuery.marquee\n * https://github.com/aamirafridi/jQuery.Marquee\n */\nclass marquee {\n\n  /**\n   * Constructor\n   *\n   * @param {Element} el - The element where the marquee is applied\n   * @param {defaultOptions} opts - the options\n   */\n  constructor( el, opts ) {\n\n    if ( typeof el === 'undefined' )\n      throw new Error( 'el cannot be undefined' );\n\n    if ( typeof el === 'string' )\n      throw new Error( 'el cannot be just a selector' );\n\n    if ( el === null )\n      throw new Error( 'el cannot be null' );\n\n    opts = {\n      ...defOpts,\n      ...opts,\n    };\n\n    this.el = el;\n    this._loopCount = 3;\n\n    // Check for data-option since they have top priority\n    for ( const option in defOpts ) {\n\n      let currData = getAttr( el, `data-${defOpts[option]}` );\n\n      if ( currData !== null && currData !== '' ) {\n\n        if ( currData === 'true' || currData === 'false' )\n          currData = Boolean( currData );\n\n        opts[option] = currData;\n\n      }\n\n    }\n\n    // Reintroduce speed as an option. It calculates duration as a factor of the container width\n    // measured in pixels per second.\n    if ( opts.speed )\n      opts.duration = parseInt( el.clientWidth ) / opts.speed * 1000;\n\n    // no gap if not duplicated\n    opts.gap = opts.duplicated ? parseInt( opts.gap ) : 0;\n\n    // wrap inner content into a div\n    el.innerHTML = `<div class=\"js-marquee\">${el.innerHTML}</div>`;\n\n    // Make a copy of the element\n    const marq = byClass( 'js-marquee', el )[0];\n\n    marq.style.marginRight = `${opts.gap}px`;\n    marq.style.willChange  = 'transform';\n    marq.style.float       = 'left';\n\n    if ( opts.duplicated )\n      el.appendChild( marq.cloneNode( true ) );\n\n    // wrap both inner elements into one div\n    el.innerHTML = `<div style=\"width:100000px\" class=\"js-marquee-wrapper\">${el.innerHTML}</div>`;\n\n    // Save the reference of the wrapper\n    const marqWrap = byClass( 'js-marquee-wrapper', el )[0],\n      vertical     = ( opts.direction === 'up' || opts.direction === 'down' );\n\n    this._marqWrap = marqWrap;\n    this._vertical = vertical;\n    this._duration = opts.duration;\n    this._opts     = opts;\n\n    this._calcSizes();\n\n    const animationName = `marqueeAnimation-${Math.floor( Math.random() * 10000000 )}`,\n      animStr           = this._animationStr(\n        animationName,\n        opts.duration / 1000,\n        opts.delayBeforeStart / 1000,\n        'infinite',\n      );\n\n    this._animName = animationName;\n    this._animStr = animStr;\n\n    // if duplicated option is set to true than position the wrapper\n    if ( opts.duplicated ) {\n\n      if ( vertical ) {\n\n        if ( opts.startVisible )\n          this._marqWrap.style.transform = 'translateY(0px)';\n        else\n          this._marqWrap.style.transform = `translateY(${opts.direction === 'up' ? this._contHeight : ( -1 * ( ( this._elHeight * 2 ) - opts.gap ) )}px)`;\n\n      } else {\n\n        if ( opts.startVisible ) // eslint-disable-line no-lonely-if\n          this._marqWrap.style.transform = 'translateX(0px)';\n        else\n          this._marqWrap.style.transform = `translateX(${opts.direction === 'left' ? this._contWidth : ( -1 * ( ( this._elWidth * 2 ) - opts.gap ) )}px)`;\n\n      }\n\n      // If the text starts out visible we can skip the two initial loops\n      if ( !opts.startVisible )\n        this._loopCount = 1;\n\n    } else if ( opts.startVisible ) {\n\n      // We only have two different loops if marquee is duplicated and starts visible\n      this._loopCount = 2;\n\n    } else {\n\n      if ( vertical ) // eslint-disable-line no-lonely-if\n        this._repositionVert();\n      else\n        this._repositionHor();\n\n    }\n\n    addEvent( this.el, 'pause', this.pause.bind( this ) );\n    addEvent( this.el, 'resume', this.resume.bind( this ) );\n\n    if ( opts.pauseOnHover ) {\n\n      addEvent( this.el, 'mouseover', this.pause.bind( this ) );\n      addEvent( this.el, 'mouseout', this.resume.bind( this ) );\n\n    }\n\n    /**\n     * Method for animation end event\n     */\n    this._animEnd = () => {\n      this._animate( vertical );\n      this.el.dispatchEvent( new CustomEvent( 'finished' ) );\n    };\n\n    this._instance = instances;\n    instances++;\n\n    this._animate( vertical );\n\n    if ( opts.recalcResize )\n      addEvent( window, 'resize', this._recalcResize.bind( this ) );\n\n  }\n\n  /**\n   * Build the css string for the animation\n   *\n   * @privte\n   * @param {String} [name=''] - animation name\n   * @param {Number} [duration=0] - Animation duration (in s)\n   * @param {Number} [delay=0] - Animation delay before starting (in s)\n   * @param {String} [loops=''] - Animation iterations\n   *\n   * @returns {String} css animation string\n   */\n  _animationStr( name = '', duration = 0, delay = 0, loops = '' ) {\n    return `${name} ${duration}s ${delay}s ${loops} ${this._opts.css3easing}`;\n  }\n\n  /**\n   * Animation of the marquee\n   *\n   * @private\n   * @param {Boolean} vertical - Vertical direction\n   */\n  _animate( vertical = false ) {\n\n    const opts = this._opts;\n\n    if ( opts.duplicated ) {\n\n      // When duplicated, the first loop will be scroll longer so double the duration\n      if ( this._loopCount === 1 ) {\n\n        let duration = opts.duration;\n\n        if ( vertical )\n          duration = ( opts.direction === 'up' ) ? duration + ( this._contHeight / ( this._elHeight / duration ) ) : duration * 2;\n        else\n          duration = ( opts.direction === 'left' ) ? duration + ( this._contWidth / ( this._elWidth / duration ) ) : duration * 2;\n\n        this._animStr = this._animationStr(\n          this._animName,\n          duration / 1000,\n          opts.delayBeforeStart / 1000,\n        );\n\n      // On 2nd loop things back to normal, normal duration for the rest of animations\n      } else if ( this._loopCount === 2 ) {\n        this._animName = `${this._animName}0`;\n        this._animStr = this._animationStr(\n          this._animName,\n          opts.duration / 1000,\n          0,\n          'infinite',\n        );\n      }\n\n      this._loopCount++;\n\n    }\n\n    let animationCss = '';\n\n    if ( vertical ) {\n      if ( opts.duplicated ) {\n\n        // Adjust the starting point of animation only when first loops finishes\n        if ( this._loopCount > 2 )\n          this._marqWrap.style.transform = `translateY(${( opts.direction === 'up' ) ? 0 : -1 * this._elHeight}px)`;\n\n        animationCss = `translateY(${( opts.direction === 'up' ) ? -1 * this._elHeight : 0}px)`;\n\n      } else if ( opts.startVisible ) {\n\n        // This loop moves the marquee out of the container\n        if ( this._loopCount === 2 ) {\n\n          // Adjust the css3 animation as well\n          this._animStr = this._animationStr(\n            this._animName,\n            opts.duration / 1000,\n            opts.delayBeforeStart / 1000,\n          );\n          animationCss = `translateY(${( opts.direction === 'up' ) ? -1 * this._elHeight : this._contHeight}px)`;\n\n          this._loopCount++;\n\n        } else if ( this._loopCount === 3 ) {\n\n          this._animName = `${this._animName}0`;\n          this._animStr = this._animationStr(\n            this._animName,\n            this._completeDuration / 1000,\n            0,\n            'infinite',\n          );\n          this._repositionVert();\n\n        }\n\n      } else {\n\n        this._repositionVert();\n        animationCss = `translateY(${( opts.direction === 'up' ) ? -1 * this._marqWrap.clientHeight : this._contHeight}px)`;\n\n      }\n    } else {\n\n      if ( opts.duplicated ) { // eslint-disable-line no-lonely-if\n\n        // Adjust the starting point of animation only when first loops finishes\n        if ( this._loopCount > 2 )\n          this._marqWrap.style.transform = `translateX(${( opts.direction === 'left' ) ? 0 : -1 * this._elWidth}px)`;\n\n        animationCss = `translateX(${( opts.direction === 'left' ) ? -1 * this._elWidth : 0}px)`;\n\n      } else if ( opts.startVisible ) {\n\n        // This loop moves the marquee out of the container\n        if ( this._loopCount === 2 ) {\n\n          // Adjust the css3 animation as well\n          this._animStr = this._animationStr(\n            this._animName,\n            opts.duration / 1000,\n            opts.delayBeforeStart / 1000,\n          );\n          animationCss = `translateX(${( opts.direction === 'left' ) ? -1 * this._elWidth : this._contWidth}px)`;\n\n          this._loopCount++;\n\n        } else if ( this._loopCount === 3 ) {\n\n          // Adjust the animation\n          this._animName = `${this._animName}0`;\n          this._animStr = this._animationStr(\n            this._animName,\n            opts.duration / 1000,\n            0,\n            'infinite',\n          );\n          this._repositionHor();\n\n        }\n\n      } else {\n        this._repositionHor();\n        animationCss = `translateX(${( opts.direction === 'left' ) ? -1 * this._elWidth : this._contWidth}px)`;\n      }\n    }\n\n    // fire event\n    this.el.dispatchEvent( new CustomEvent( 'beforeStarting' ) );\n\n    // Append animation\n    this._marqWrap.style.animation = this._animStr;\n\n    const keyFrameCss = `@keyframes ${this._animName} {\n        100% {\n          transform: ${animationCss};\n        }\n      }`,\n      styles = queryAll( 'style', this._marqWrap );\n\n    if ( styles.length )\n      styles[styles.length - 1].innerHTML = keyFrameCss;\n    else if ( byClass( `marq-wrap-style-${this._instance}` ).length )\n      byClass( `marq-wrap-style-${this._instance}` )[0].innerHTML = keyFrameCss;\n    else {\n\n      const styleEl = document.createElement( 'style' );\n      addClass( styleEl, `marq-wrap-style-${this._instance}` );\n      styleEl.innerHTML = keyFrameCss;\n\n      query( 'head' ).appendChild( styleEl );\n\n    }\n\n    // Animation iteration event\n    addEvent( this._marqWrap, 'animationiteration', this._animIter.bind( this ), {\n      once: true,\n    });\n\n    // Animation stopped\n    addEvent( this._marqWrap, 'animationend', this._animEnd.bind( this ), {\n      once: true,\n    });\n\n    this._status = 'running';\n    setAttr( this.el, 'data-runningStatus', 'resumed' );\n\n  }\n\n  /**\n   * Event fired on Animation iteration\n   *\n   * @private\n   */\n  _animIter() {\n    this.el.dispatchEvent( new CustomEvent( 'finished' ) );\n  }\n\n  /**\n   * Reposition the Wrapper vertically\n   *\n   * @private\n   */\n  _repositionVert() {\n    this._marqWrap.style.transform = `translateY(${this._opts.direction === 'up' ? this._contHeight : ( this._elHeight * -1 )}px)`;\n  }\n\n  /**\n   * Reposition the Wrapper horizontally\n   *\n   * @private\n   */\n  _repositionHor() {\n    this._marqWrap.style.transform = `translateX(${this._opts.direction === 'left' ? this._contWidth : ( this._elWidth * -1 )}px)`;\n  }\n\n  /**\n   * Calculates the speed and the dimension of the marquee\n   *\n   * @private\n   */\n  _calcSizes() {\n\n    const el = this.el,\n      opts   = this._opts;\n\n    // If direction is up or down, get the height of main element\n    if ( this._vertical ) {\n\n      const contHeight = el.clientHeight;\n      this._contHeight = contHeight;\n\n      remAttr( this._marqWrap, 'style' );\n\n      el.style.clientHeight = `${contHeight}px`;\n\n      const marqs = byClass( 'js-marquee', el ),\n        marqNums  = marqs.length - 1;\n\n      // Change the CSS for js-marquee element\n      forEachHTML( marqs, ( currEl, ind ) => {\n\n        currEl.style.float        = 'none';\n        currEl.style.marginRight  = '0px';\n\n        // Remove bottom margin from 2nd element if duplicated\n        if ( opts.duplicated && ind === marqNums )\n          currEl.style.marginBottom = '0px';\n        else\n          currEl.style.marginBottom = `${opts.gap}px`;\n\n      });\n\n      const elHeight = parseInt( marqs[0].clientHeight + opts.gap );\n      this._elHeight = elHeight;\n\n      // adjust the animation duration according to the text length\n      if ( opts.startVisible && !opts.duplicated ) {\n        // Compute the complete animation duration and save it for later reference\n        // formula is to: (Height of the text node + height of the main container / Height of the main container) * duration;\n        this._completeDuration = ( elHeight + contHeight ) / parseInt( contHeight ) * this._duration; // eslint-disable-line max-len\n        opts.duration = elHeight / parseInt( contHeight ) * this._duration;\n      } else // formula is to: (Height of the text node + height of the main container / Height of the main container) * duration;\n        opts.duration = elHeight / parseInt( contHeight ) / parseInt( contHeight ) * this._duration;\n\n    } else {\n\n      // Save the width of the each element so we can use it in animation\n      const elWidth = parseInt( byClass( 'js-marquee', el )[0].clientWidth + opts.gap ),\n        contWidth   = el.clientWidth;\n\n      this._contWidth = contWidth;\n      this._elWidth   = elWidth;\n\n      // adjust the animation duration according to the text length\n      if ( opts.startVisible && !opts.duplicated ) {\n        // Compute the complete animation duration and save it for later reference\n        // formula is to: (Width of the text node + width of the main container / Width of the main container) * duration;\n        this._completeDuration = ( elWidth + contWidth ) / parseInt( contWidth ) * this._duration;\n        // (Width of the text node / width of the main container) * duration\n        opts.duration = elWidth / parseInt( contWidth ) * this._duration;\n      } else // formula is to: (Width of the text node + width of the main container / Width of the main container) * duration;\n        opts.duration = ( elWidth + parseInt( contWidth ) ) / parseInt( contWidth ) * this._duration; // eslint-disable-line max-len\n    }\n\n    // if duplicated then reduce the duration\n    if ( opts.duplicated )\n      opts.duration = opts.duration / 2;\n\n  }\n\n  /**\n   * Recalculates the dimensions and positon of the marquee on page resize\n   *\n   * @private\n   */\n  _recalcResize() {\n\n    this._calcSizes();\n\n    this._loopCount = 2;\n    this._animEnd();\n\n  }\n\n  /**\n   * Pause the animation\n   */\n  pause() {\n    this._marqWrap.style.animationPlayState = 'paused';\n    this._status = 'paused';\n\n    setAttr( this.el, 'data-runningStatus', 'paused' );\n    this.el.dispatchEvent( new CustomEvent( 'paused' ) );\n  }\n\n  /**\n   * Resume the animation\n   */\n  resume() {\n    this._marqWrap.style.animationPlayState = 'running';\n    this._status = 'running';\n\n    setAttr( this.el, 'data-runningStatus', 'resumed' );\n    this.el.dispatchEvent( new CustomEvent( 'resumed' ) );\n  }\n\n  /**\n   * Toggle animation playing status\n   */\n  toggle() {\n\n    if ( this._status === 'paused' )\n      this.resume();\n    else if ( this._status === 'running' )\n      this.pause();\n\n  }\n\n  /**\n   * Destorys the instance and removes events\n   */\n  destroy() {\n\n    removeEvent( this.el, 'pause', this.pause.bind( this ) );\n    removeEvent( this.el, 'resume', this.resume.bind( this ) );\n\n    if ( this._opts.pauseOnHover ) {\n\n      removeEvent( this.el, 'mouseover', this.pause.bind( this ) );\n      removeEvent( this.el, 'mouseout', this.resume.bind( this ) );\n\n    }\n\n    removeEvent( this._marqWrap, 'animationiteration', this._animIter.bind( this ), {\n      once: true,\n    });\n\n    removeEvent( this._marqWrap, 'animationend', this._animEnd.bind( this ), {\n      once: true,\n    });\n\n    if ( this._opts.recalcResize )\n      removeEvent( window, 'resize', this._recalcResize.bind( this ) );\n\n  }\n\n  /**\n   * Forces a refresh (like recalcResize) but done manually\n   */\n  refresh() {\n    this._recalcResize();\n  }\n\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/vanilla-marquee/dist/vanilla-marquee.js?");

/***/ })

}]);